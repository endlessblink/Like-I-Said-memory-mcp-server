{
  "extracted_tools": {
    "1": {
      "name": "add_memory",
      "description": "AUTOMATICALLY use when user shares important information, code snippets, decisions, learnings, or context that should be remembered for future sessions. Includes smart categorization and auto-linking.",
      "source_lines": "601-643",
      "inputSchema": {
        "type": "object",
        "properties": {
          "content": {
            "type": "string",
            "description": "The memory content to store"
          },
          "tags": {
            "type": "array",
            "items": { "type": "string" },
            "description": "Optional tags for the memory"
          },
          "category": {
            "type": "string",
            "description": "Memory category (personal, work, code, research, conversations, preferences)"
          },
          "project": {
            "type": "string",
            "description": "Project name to organize memory files"
          },
          "priority": {
            "type": "string",
            "description": "Priority level (low, medium, high)"
          },
          "status": {
            "type": "string",
            "description": "Memory status (active, archived, reference)"
          },
          "related_memories": {
            "type": "array",
            "items": { "type": "string" },
            "description": "IDs of related memories for cross-referencing"
          },
          "language": {
            "type": "string",
            "description": "Programming language for code content"
          }
        },
        "required": ["content"]
      },
      "validation_notes": [
        "Only content is required, all other fields are optional",
        "Arrays for tags and related_memories allow multiple values",
        "String enums for category, priority, and status should be validated",
        "Language field specifically for code content categorization"
      ]
    },
    "2": {
      "name": "get_memory",
      "description": "Retrieve a memory by ID",
      "source_lines": "645-657",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The memory ID to retrieve"
          }
        },
        "required": ["id"]
      },
      "validation_notes": [
        "Simple schema with only one required field: id",
        "ID must be a string type",
        "No optional parameters",
        "Basic retrieval operation by unique identifier"
      ]
    },
    "3": {
      "name": "list_memories",
      "description": "List all stored memories or memories from a specific project",
      "source_lines": "659-673",
      "inputSchema": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "number",
            "description": "Maximum number of memories to return"
          },
          "project": {
            "type": "string",
            "description": "Filter by project name"
          }
        }
      },
      "validation_notes": [
        "No required fields - all parameters are optional",
        "limit is numeric type for pagination control",
        "project string for filtering by project context",
        "When no parameters provided, returns all memories",
        "Should implement reasonable default limit to prevent performance issues"
      ]
    },
    "4": {
      "name": "delete_memory",
      "description": "Delete a memory by ID",
      "source_lines": "676-688",
      "inputSchema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The memory ID to delete"
          }
        },
        "required": ["id"]
      },
      "validation_notes": [
        "Simple schema identical to get_memory structure",
        "Only one required field: id (string type)",
        "Destructive operation - should implement safety checks",
        "Should return confirmation of deletion or error if ID not found",
        "Consider implementing soft delete vs hard delete options"
      ]
    },
    "5": {
      "name": "search_memories",
      "description": "AUTOMATICALLY use when user asks about past work, previous decisions, looking for examples, or needs context from earlier sessions. Provides semantic and keyword-based search.",
      "source_lines": "690-705",
      "inputSchema": {
        "type": "object",
        "properties": {
          "query": {
            "type": "string",
            "description": "Search query"
          },
          "project": {
            "type": "string",
            "description": "Limit search to specific project"
          }
        },
        "required": ["query"]
      },
      "validation_notes": [
        "Requires query string parameter for search terms",
        "Optional project parameter for filtering by project context",
        "Supports both semantic and keyword-based search",
        "Should implement fuzzy matching and relevance scoring",
        "Query preprocessing may be needed for optimal search results"
      ]
    }
  },
  "extraction_metadata": {
    "source_file": "/home/endlessblink/projects/like-i-said-mcp-server-v2/server-markdown.js",
    "extraction_date": "2025-07-14",
    "schema_agent": "Agent 1: Schema Extraction Specialist",
    "total_tools_extracted": 5,
    "memory_entries_created": 5,
    "project_context": "like-i-said-python-port"
  },
  "implementation_guidelines": {
    "required_fields_only": "Only the required fields listed in each schema are mandatory",
    "optional_validation": "Implement validation for optional enum fields (category, priority, status)",
    "error_handling": "Each tool should handle missing IDs gracefully with appropriate error messages",
    "performance_notes": "list_memories should implement reasonable default limits",
    "security_notes": "delete_memory should implement confirmation mechanisms"
  }
}